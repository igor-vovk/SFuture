// Generated by CoffeeScript 1.9.1
(function() {
  var newPromise, passFailureToPromise, passSuccessToPromise, tryCompletingPromise;

  passSuccessToPromise = function(p) {
    return function(s) {
      return p.success(s);
    };
  };

  passFailureToPromise = function(p) {
    return function(e) {
      return p.failure(e);
    };
  };

  newPromise = function(f) {
    var p;
    p = SPromise.apply();
    f(p);
    return p.future();
  };

  tryCompletingPromise = function(p, f) {
    var error, success, val;
    val = null;
    error = null;
    success = false;
    try {
      val = f();
      success = true;
    } catch (_error) {
      error = _error;
    } finally {
      if (success) {
        p.success(val);
      } else {
        p.failed(error);
      }
    }
  };

  window.SPromise = (function() {
    var _ref;

    function SPromise() {}

    _ref = null;

    SPromise.apply = function() {
      return new SPromise();
    };

    SPromise.successful = function(result) {
      return SPromise.apply().success(result);
    };

    SPromise.failed = function(err) {
      return SPromise.apply().failure(err);
    };

    SPromise.prototype.future = function() {
      if (_ref === null) {
        _ref = new SFuture();
      }
      return _ref;
    };

    SPromise.prototype.isCompleted = function() {
      return _ref !== null && _ref.isCompleted();
    };

    SPromise.prototype.join = function(otherFuture) {
      otherFuture.onComplete(passSuccessToPromise(this), passFailureToPromise(this));
    };

    SPromise.prototype.success = function(value) {
      this.future().setState(value);
    };

    SPromise.prototype.failure = function(cause) {
      this.future().setState(cause, false);
    };

    return SPromise;

  })();

  window.SFuture = (function() {
    var _handlers, _state, _stateSet;

    function SFuture() {}

    _handlers = {
      s: [],
      f: []
    };

    _stateSet = 0;

    _state = null;

    SFuture.apply = function(func, timeout) {
      if (timeout == null) {
        timeout = 0;
      }
      return newPromise(function(p) {
        var delayedF;
        delayedF = function() {
          tryCompletingPromise(p, func);
        };
        setTimeout(delayedF, timeout);
      });
    };

    SFuture.failed = function(err) {
      return SPromise.failed(err).future();
    };

    SFuture.successful = function(result) {
      return SPromise.successful(result).future();
    };

    SFuture.sequence = function(futures) {
      var f, i, len, result;
      result = SFuture.successful([]);
      for (i = 0, len = futures.length; i < len; i++) {
        f = futures[i];
        result = result.flatMap(function(r) {
          return f.map(function(v) {
            return r.push(v);
          });
        });
      }
      return result;
    };

    SFuture.traverse = function(list, fn) {
      var fb, i, item, len, result;
      result = SFuture.successful([]);
      for (i = 0, len = list.length; i < len; i++) {
        item = list[i];
        fb = fn(item);
        result = result.flatMap(function(items) {
          return fb.map(function(res) {
            return items.push(res);
          });
        });
      }
      return result;
    };

    SFuture.firstCompletedOf = function(futures) {
      return newPromise(function(p) {
        var f, i, len;
        for (i = 0, len = futures.length; i < len; i++) {
          f = futures[i];
          p.join(f);
        }
      });
    };

    SFuture.prototype.setState = function(s, succ) {
      var exc, exceptions, h, i, len, ref;
      if (succ == null) {
        succ = true;
      }
      if (this.isCompleted()) {
        return;
      }
      _state = s;
      _stateSet = succ ? 1 : -1;
      exceptions = [];
      ref = (succ ? _handlers.s : _handlers.f);
      for (i = 0, len = ref.length; i < len; i++) {
        h = ref[i];
        try {
          h(s);
        } catch (_error) {
          exc = _error;
          exceptions.push(exc);
        }
      }
      _handlers = null;
      if (exceptions.length > 0) {
        throw exceptions;
      }
    };

    SFuture.prototype.onSuccess = function(cb) {
      if (this.isCompleted()) {
        if (this.isSuccessful()) {
          cb(_state);
        }
      } else {
        _handlers.s.push(cb);
      }
    };

    SFuture.prototype.onFailure = function(cb) {
      if (this.isCompleted()) {
        if (!(this.isSuccessful())) {
          cb(_state);
        }
      } else {
        _handlers.f.push(cb);
      }
    };

    SFuture.prototype.onComplete = function(success, failure) {
      this.onSuccess(success);
      this.onFailure(failure);
    };

    SFuture.prototype.isCompleted = function() {
      return _stateSet !== 0;
    };

    SFuture.prototype.isSuccessful = function() {
      if (!this.isCompleted()) {
        throw "Calling isSuccessful on incomplete SFuture is not allowed";
      } else {
        return _stateSet > 0;
      }
    };

    SFuture.prototype.map = function(mapper) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(function(s) {
            return tryCompletingPromise(p, function() {
              return mapper(s);
            });
          }, passFailureToPromise(p));
        };
      })(this));
    };

    SFuture.prototype.flatMap = function(flatMapper) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(function(s) {
            var error;
            try {
              return p.join(flatMapper(s));
            } catch (_error) {
              error = _error;
              return p.failure(error);
            }
          }, passFailureToPromise(p));
        };
      })(this));
    };

    SFuture.prototype.filter = function(filter) {
      return newPromise(function(p) {
        this.onComplete(function(s) {
          if (filter(s)) {
            return p.success(s);
          } else {
            return p.failure("SFuture.filter predicate is not satisfied");
          }
        }, passFailureToPromise(p));
      });
    };

    SFuture.prototype.zip = function(that) {
      return newPromise(function(p) {
        this.onComplete(function(s) {
          return that.onComplete(function(thatS) {
            return p.success([s, thatS]);
          }, passFailureToPromise(p));
        }, passFailureToPromise(p));
      });
    };

    SFuture.prototype.fallbackTo = function(that) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(passSuccessToPromise(p), function(e) {
            return that.onComplete(passSuccessToPromise(p), function() {
              return p.failure(e);
            });
          });
        };
      })(this));
    };

    SFuture.prototype.recover = function(f) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(passSuccessToPromise(p), function(e) {
            return tryCompletingPromise(p, function() {
              return f(e);
            });
          });
        };
      })(this));
    };

    SFuture.prototype.recoverWith = function(f) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(passSuccessToPromise(p), function(e) {
            var error;
            p.join((function() {
              try {
                return f(e);
              } catch (_error) {
                error = _error;
                return SFuture.failed(error);
              }
            })());
          });
        };
      })(this));
    };

    SFuture.prototype.andThen = function(sf, ff) {
      return newPromise((function(_this) {
        return function(p) {
          _this.onComplete(function(s) {
            sf(s);
            return p.success(s);
          }, function(e) {
            ff(e);
            return p.failure(e);
          });
        };
      })(this));
    };

    return SFuture;

  })();

}).call(this);
