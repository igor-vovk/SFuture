// Generated by CoffeeScript 1.7.1
var SFuture, SPromise;

SPromise = (function() {
  var _ref;

  function SPromise() {}

  _ref = null;

  SPromise.apply = function() {
    return new SPromise();
  };

  SPromise.successful = function(result) {
    return SPromise.apply().success(result);
  };

  SPromise.failed = function(err) {
    return SPromise.apply().failure(err);
  };

  SPromise.prototype.future = function() {
    if (_ref === null) {
      _ref = new SFuture();
    }
    return _ref;
  };

  SPromise.prototype.isCompleted = function() {
    return _ref !== null && _ref.isCompleted();
  };

  SPromise.prototype.join = function(otherFuture) {
    otherFuture.onComplete((function(_this) {
      return function(s) {
        return _this.success(s);
      };
    })(this), (function(_this) {
      return function(e) {
        return _this.failure(e);
      };
    })(this));
  };

  SPromise.prototype.success = function(value) {
    this.future().setState(value);
  };

  SPromise.prototype.failure = function(cause) {
    this.future().setState(cause, false);
  };

  return SPromise;

})();

SFuture = (function() {
  var newPromise, _handlers, _state, _stateSet;

  function SFuture() {}

  _handlers = {
    s: [],
    f: []
  };

  _stateSet = 0;

  _state = null;

  newPromise = function(f) {
    var p;
    p = SPromise.apply();
    f(p);
    return p.future();
  };

  SFuture.apply = function(func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    return newPromise(function(p) {
      var delayedF;
      delayedF = function() {
        var error;
        try {
          p.success(func());
        } catch (_error) {
          error = _error;
          p.failure(error);
        }
      };
      setTimeout(delayedF, timeout);
    });
  };

  SFuture.failed = function(err) {
    return SPromise.failed(err).future();
  };

  SFuture.successful = function(result) {
    return SPromise.successful(result).future();
  };

  SFuture.sequence = function(futures) {
    var f, result, _i, _len;
    result = SFuture.successful([]);
    for (_i = 0, _len = futures.length; _i < _len; _i++) {
      f = futures[_i];
      result = result.flatMap(function(r) {
        return f.map(function(v) {
          return r.push(v);
        });
      });
    }
    return result;
  };

  SFuture.traverse = function(list, fn) {
    var fb, item, result, _i, _len;
    result = SFuture.successful([]);
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      fb = fn(item);
      result = result.flatMap(function(items) {
        return fb.map(function(res) {
          return items.push(res);
        });
      });
    }
    return result;
  };

  SFuture.firstCompletedOf = function(futures) {
    return newPromise(function(p) {
      var f, _i, _len;
      for (_i = 0, _len = futures.length; _i < _len; _i++) {
        f = futures[_i];
        p.join(f);
      }
    });
  };

  SFuture.prototype.setState = function(s, succ) {
    var h, _i, _len, _ref;
    if (succ == null) {
      succ = true;
    }
    if (this.isCompleted()) {
      return;
    }
    _state = s;
    _stateSet = succ ? 1 : -1;
    _ref = (succ ? _handlers.s : _handlers.f);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      h(s);
    }
    _handlers = null;
  };

  SFuture.prototype.onSuccess = function(cb) {
    if (this.isCompleted()) {
      if (this.isSuccessful()) {
        cb(_state);
      }
    } else {
      _handlers.s.push(cb);
    }
  };

  SFuture.prototype.onFailure = function(cb) {
    if (this.isCompleted()) {
      if (!(this.isSuccessful())) {
        cb(_state);
      }
    } else {
      _handlers.f.push(cb);
    }
  };

  SFuture.prototype.onComplete = function(success, failure) {
    this.onSuccess(success);
    this.onFailure(failure);
  };

  SFuture.prototype.isCompleted = function() {
    return _stateSet !== 0;
  };

  SFuture.prototype.isSuccessful = function() {
    if (!this.isCompleted()) {
      throw "Calling isSuccessful on incomplete SFuture is not allowed";
    } else {
      return _stateSet > 0;
    }
  };

  SFuture.prototype.map = function(mapper) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onComplete(function(s) {
          var error;
          try {
            return p.success(mapper(s));
          } catch (_error) {
            error = _error;
            return p.failure(error);
          }
        }, function(e) {
          return p.failure(e);
        });
      };
    })(this));
  };

  SFuture.prototype.flatMap = function(flatMapper) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onComplete(function(s) {
          var error;
          try {
            return p.join(flatMapper(s));
          } catch (_error) {
            error = _error;
            return p.failure(error);
          }
        }, function(e) {
          return p.failure(e);
        });
      };
    })(this));
  };

  SFuture.prototype.filter = function(filter) {
    return newPromise(function(p) {
      this.onComplete(function(s) {
        if (filter(s)) {
          return p.success(s);
        } else {
          return p.failure("SFuture.filter predicate is not satisfied");
        }
      }, function(e) {
        return p.failure(e);
      });
    });
  };

  SFuture.prototype.zip = function(that) {
    return newPromise(function(p) {
      this.onComplete(function(s) {
        return that.onComplete(function(thatS) {
          return p.success([s, thatS]);
        }, function(e) {
          return p.failure(e);
        });
      }, function(e) {
        return p.failure(e);
      });
    });
  };

  SFuture.prototype.fallbackTo = function(that) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onComplete(function(s) {
          return p.success(s);
        }, function(e) {
          return that.onComplete(function(thatS) {
            return p.success(thatS);
          }, function() {
            return p.failure(e);
          });
        });
      };
    })(this));
  };

  SFuture.prototype.recover = function(f) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onFailure(function(e) {
          var error;
          try {
            p.success(f(e));
          } catch (_error) {
            error = _error;
            p.failed(error);
          }
        });
      };
    })(this));
  };

  SFuture.prototype.recoverWith = function(f) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onFailure(function(e) {
          var error, future;
          future = (function() {
            try {
              return f(e);
            } catch (_error) {
              error = _error;
              return SFuture.failed(error);
            }
          })();
          future.onComplete(function(thatS) {
            return p.success(thatS);
          }, function(thatE) {
            return p.failure(thatE);
          });
        });
      };
    })(this));
  };

  SFuture.prototype.andThen = function(sf, ff) {
    return newPromise((function(_this) {
      return function(p) {
        _this.onComplete(function(s) {
          sf(s);
          return p.success(s);
        }, function(e) {
          ff(e);
          return p.failure(e);
        });
      };
    })(this));
  };

  return SFuture;

})();
