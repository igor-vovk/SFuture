// Generated by CoffeeScript 1.7.1
var SFuture, SPromise;

SPromise = (function() {
  var _ref;

  function SPromise() {}

  _ref = null;

  SPromise.apply = function() {
    return new SPromise();
  };

  SPromise.successful = function(result) {
    return SPromise.apply().success(result);
  };

  SPromise.failed = function(err) {
    return SPromise.apply().failure(err);
  };

  SPromise.prototype.future = function() {
    if (_ref === null) {
      _ref = new SFuture();
    }
    return _ref;
  };

  SPromise.prototype.isCompleted = function() {
    return _ref !== null && _ref.isCompleted();
  };

  SPromise.prototype.join = function(otherFuture) {
    otherFuture.onComplete((function(_this) {
      return function(s) {
        return _this.success(s);
      };
    })(this), (function(_this) {
      return function(e) {
        return _this.failure(e);
      };
    })(this));
  };

  SPromise.prototype.success = function(value) {
    this.future().setState(value);
  };

  SPromise.prototype.failure = function(cause) {
    this.future().setState(cause, false);
  };

  return SPromise;

})();

SFuture = (function() {
  var _handlers, _state, _stateSet;

  function SFuture() {}

  _handlers = {
    s: [],
    f: []
  };

  _stateSet = 0;

  _state = null;

  SFuture.apply = function(func, timeout) {
    var f, p;
    if (timeout == null) {
      timeout = 0;
    }
    p = SPromise.apply();
    f = function() {
      var error;
      try {
        p.success(func());
      } catch (_error) {
        error = _error;
        p.failure(error);
      }
    };
    setTimeout(f, timeout);
    return p.future();
  };

  SFuture.failed = function(err) {
    return SPromise.failed(err).future();
  };

  SFuture.successful = function(result) {
    return SPromise.successful(result).future();
  };

  SFuture.sequence = function(futures) {
    var f, result, _i, _len;
    result = SFuture.successful([]);
    for (_i = 0, _len = futures.length; _i < _len; _i++) {
      f = futures[_i];
      result = result.flatMap(function(r) {
        return f.map(function(v) {
          return r.push(v);
        });
      });
    }
    return result;
  };

  SFuture.firstCompletedOf = function(futures) {
    var f, p, _i, _len;
    p = SPromise.apply();
    for (_i = 0, _len = futures.length; _i < _len; _i++) {
      f = futures[_i];
      p.join(f);
    }
    return p.future();
  };

  SFuture.prototype.setState = function(s, succ) {
    var h, _i, _len, _ref;
    if (succ == null) {
      succ = true;
    }
    if (this.isCompleted()) {
      return;
    }
    _state = s;
    _stateSet = succ ? 1 : -1;
    _ref = (succ ? _handlers.s : _handlers.f);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      h(s);
    }
    _handlers = null;
  };

  SFuture.prototype.onSuccess = function(cb) {
    if (this.isCompleted()) {
      if (this.isSuccessful()) {
        cb(_state);
      }
    } else {
      _handlers.s.push(cb);
    }
  };

  SFuture.prototype.onFailure = function(cb) {
    if (this.isCompleted()) {
      if (!(this.isSuccessful())) {
        cb(_state);
      }
    } else {
      _handlers.f.push(cb);
    }
  };

  SFuture.prototype.onComplete = function(success, failure) {
    this.onSuccess(success);
    this.onFailure(failure);
  };

  SFuture.prototype.isCompleted = function() {
    return _stateSet !== 0;
  };

  SFuture.prototype.isSuccessful = function() {
    if (!this.isCompleted()) {
      throw "Calling isSuccessful on incomplete SFuture is not allowed";
    } else {
      return _stateSet > 0;
    }
  };

  SFuture.prototype.map = function(mapper) {
    var p;
    p = SPromise.apply();
    this.onComplete(function(s) {
      var error;
      try {
        return p.success(mapper(s));
      } catch (_error) {
        error = _error;
        return p.failure(error);
      }
    }, function(e) {
      return p.failure(e);
    });
    return p.future();
  };

  SFuture.prototype.flatMap = function(flatMapper) {
    var p;
    p = SPromise.apply();
    this.onComplete(function(s) {
      var error;
      try {
        return p.join(flatMapper(s));
      } catch (_error) {
        error = _error;
        return p.failure(error);
      }
    }, function(e) {
      return p.failure(e);
    });
    return p.future();
  };

  SFuture.prototype.filter = function(filter) {
    var p;
    p = SPromise.apply();
    onComplete(function(s) {
      if (filter(s)) {
        return p.success(s);
      } else {
        return p.failure("SFuture.filter predicate is not satisfied");
      }
    }, function(e) {
      return p.failure(e);
    });
    return p.future();
  };

  SFuture.prototype.zip = function(that) {
    var p;
    p = SPromise.apply();
    return this.onComplete(function(s) {
      return that.onComplete(function(thatS) {
        return p.success([s, thatS]);
      }, function(e) {
        return p.failure(e);
      });
    }, function(e) {
      return p.failure(e);
    });
  };

  SFuture.prototype.fallbackTo = function(that) {
    var p;
    p = SPromise.apply();
    this.onComplete(function(s) {
      return p.success(s);
    }, function(e) {
      return that.onComplete(function(thatS) {
        return p.success(thatS);
      }, function() {
        return p.failure(e);
      });
    });
    return p.future();
  };

  SFuture.prototype.andThen = function(succes, failure) {
    var p;
    p = SPromise.apply();
    this.onComplete(function(s) {
      succes(s);
      return p.success(s);
    }, function(e) {
      failure(e);
      return p.failure(e);
    });
    return p.future();
  };

  return SFuture;

})();
